<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Assignment 4 â€“ Lead Time & Bullwhip Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family:'Segoe UI',sans-serif; background:#f0f4f8; padding:20px; }
    .container { background:#fff; padding:30px; border-radius:8px; box-shadow:0 0 15px rgba(0,0,0,0.1); }
    .result-card { margin-top:20px; padding:20px; border-radius:8px; background:#f7fbff; box-shadow:inset 0 0 8px rgba(0,123,255,0.05); }
    .diag { margin-top:10px; font-size:0.9em; color:#555; }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center">Lead Time & Bullwhip Analysis</h1>
    <div class="d-flex gap-2 justify-content-center mb-3">
      <input type="file" id="xlsxFile" accept=".xlsx,.xls,.csv" class="form-control w-auto">
      <button class="btn btn-primary" onclick="analyze()">Analyze</button>
      <button class="btn btn-success" onclick="downloadResult()">Download Result</button>
    </div>
    <div id="results"></div>
    <canvas id="delayChart" height="100"></canvas>
    <div id="diagnostics" class="diag"></div>
  </div>

  <script>
    let currentOutput = "";
    let processedRows = 0, skippedRows = 0;

    function sanitize(s){ return s?.toString().trim().replace(/\u00A0/g, '').toLowerCase().replace(/[\s_]+/g,'')||''; }

    function analyze() {
      const f = document.getElementById('xlsxFile').files[0];
      if (!f) return alert("Please choose a file!");

      processedRows = 0; skippedRows = 0;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const wb = XLSX.read(e.target.result, { type: f.name.endsWith('.csv') ? 'string' : 'binary' });
          const rows = XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { defval: "" });
          if (rows.length === 0) return alert("Your sheet is empty!");

          const map = {};
          Object.keys(rows[0]).forEach(h => map[sanitize(h)] = h);
          console.log("Header map:", map);

          calculate(rows, map);
          document.getElementById("diagnostics").textContent =
            `âœ… Processed rows: ${processedRows} | Skipped rows: ${skippedRows}`;
        } catch (err) {
          console.error(err);
          alert("Could not read the file. Check if it's a valid Excel or CSV.");
        }
      };

      f.name.endsWith('.csv') ? reader.readAsText(f) : reader.readAsBinaryString(f);
    }

    function parseDate(v) {
      if (typeof v==='number') { 
        const d = XLSX.SSF.parse_date_code(v); 
        return d ? new Date(d.y,d.m-1,d.d) : NaN;
      }
      const d = new Date(v); 
      return isNaN(d.getTime()) ? NaN : d;
    }

    function daysBetween(a,b) {
      const d1 = parseDate(a), d2 = parseDate(b);
      return (!isNaN(d1) && !isNaN(d2)) ? (d2 - d1) / 86400000 : NaN;
    }

    function average(arr) {
      return arr.length ? arr.reduce((a,b) => a+b,0)/arr.length : NaN;
    }

    function groupBy(rows, keyFn, valFn) {
      const g = {};
      rows.forEach(r => {
        const key = typeof keyFn==='function' ? keyFn(r) : r[keyFn];
        const val = valFn(r);
        if (!isNaN(val)) {
          processedRows++;
          if (key) {
            if (!g[key]) g[key] = [];
            g[key].push(val);
            return;
          }
        }
        skippedRows++;
      });
      return g;
    }

    function calculate(rows, map) {
      function get(r, name){ return r[ map[ sanitize(name) ] ] || ""; }

      const sup = groupBy(rows, r=>get(r,"Supplier"), r=>daysBetween(get(r,"Order Date"), get(r,"Actual Delivery Date")));
      const tr = groupBy(rows, r=>get(r,"Transportation Mode"), r=>daysBetween(get(r,"Order Date"), get(r,"Actual Delivery Date")));
      const mo = groupBy(rows, r=>{
        const d = parseDate(get(r,"Expected Delivery Date"));
        return isNaN(d)?null:d.toLocaleString('default',{month:'short'});
      }, r=>daysBetween(get(r,"Expected Delivery Date"), get(r,"Actual Delivery Date")));
      const dis = groupBy(rows, r=>get(r,"Disruption Type"), r=>daysBetween(get(r,"Expected Delivery Date"), get(r,"Actual Delivery Date")));
      const cat = groupBy(rows, r=>get(r,"Product Category"), r=>daysBetween(get(r,"Order Date"), get(r,"Actual Delivery Date")));

      function best(obj) {
        const e = Object.entries(obj).filter(([,v])=>v.length);
        return e.length ? e.sort((a,b)=>average(b[1]) - average(a[1]))[0] : ["N/A", []];
      }

      const supBest = best(sup), trBest = best(tr), moWorst = best(mo), disWorst = best(dis), catBest = best(cat);

      currentOutput = `
Supplier with Highest Avg Lead Time: ${supBest[0]} â€” ${average(supBest[1]).toFixed(2)} days
Fastest Transport Mode: ${trBest[0]} â€” ${average(trBest[1]).toFixed(2)} days
Month with Highest Avg Delay: ${moWorst[0]} â€” ${average(moWorst[1]).toFixed(2)} days
Worst Disruption Type: ${disWorst[0]} â€” ${average(disWorst[1]).toFixed(2)} days
Best Product Category: ${catBest[0]} â€” ${average(catBest[1]).toFixed(2)} days`;

      document.getElementById("results").innerHTML = `
        <div class="result-card"><h2>ðŸ“Š Analysis Results</h2><pre>${currentOutput}</pre></div>`;
      drawChart(mo);
    }

    function drawChart(mo) {
      const ctx = document.getElementById('delayChart').getContext('2d');
      const labels = Object.keys(mo);
      const values = labels.map(k => average(mo[k]).toFixed(2));
      new Chart(ctx, {
        type:'bar',
        data:{labels, datasets:[{label:'Avg Delay by Month (days)', data:values, backgroundColor:'rgba(0,123,255,0.6)'}]},
        options:{responsive:true,plugins:{legend:{display:false}}}
      });
    }

    function downloadResult() {
      if (!currentOutput) return alert("No analysis available!");
      const blob = new Blob([currentOutput], { type:'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'result.txt';
      a.click();
    }
  </script>
</body>
</html>
