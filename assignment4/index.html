<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Assignment 4 â€“ Lead Time & Bullwhip Analysis</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: #e9f2fb; padding: 20px; }
    .container { background: #fff; padding: 30px; border-radius: 12px; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
    .result-card { margin-top: 30px; padding: 20px; border-radius: 10px; background: #f7faff; box-shadow: inset 0 0 10px rgba(0,123,255,0.05); }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center">Assignment 4: Lead Time & Bullwhip Analysis</h1>
    <p class="text-center">Upload your Excel file (.xlsx) and get instant analysis.</p>
    <div class="d-flex flex-wrap gap-2 justify-content-center mb-3">
      <input type="file" id="xlsxFile" accept=".xlsx" class="form-control w-auto" />
      <button class="btn btn-primary" onclick="analyze()">Analyze</button>
      <button class="btn btn-success" onclick="downloadResult()">Download Result</button>
    </div>
    <div id="results"></div>
    <canvas id="delayChart" height="100"></canvas>
  </div>

  <script>
    let currentOutput = "";

    function normalize(str) {
      return str ? str.toLowerCase().replace(/[\s_]+/g, "") : "";
    }

    function analyze() {
      const file = document.getElementById('xlsxFile').files[0];
      if (!file) return alert("Please upload an Excel file!");

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const wb = XLSX.read(e.target.result, { type: 'binary' });
          const sheet = wb.Sheets[wb.SheetNames[0]];
          const data = XLSX.utils.sheet_to_json(sheet, { defval: "" });
          if (!data.length) return alert("No rows found in sheet.");
          const headers = Object.keys(data[0]);
          const map = {};
          for (let header of headers) {
            const key = normalize(header);
            map[key] = header;
          }
          calculateResults(data, map);
        } catch (err) {
          alert("Error reading Excel file.");
        }
      };
      reader.readAsBinaryString(file);
    }

    function parseDate(val) {
      if (typeof val === 'number') {
        const d = XLSX.SSF.parse_date_code(val);
        return d ? new Date(d.y, d.m - 1, d.d) : NaN;
      } else {
        const d = new Date(val);
        return isNaN(d) ? NaN : d;
      }
    }

    function daysBetween(d1, d2) {
      d1 = parseDate(d1);
      d2 = parseDate(d2);
      return (!isNaN(d1) && !isNaN(d2)) ? (d2 - d1) / (1000 * 60 * 60 * 24) : NaN;
    }

    function average(arr) {
      return arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : NaN;
    }

    function groupBy(data, keyFn, valFn) {
      const groups = {};
      for (const row of data) {
        const key = typeof keyFn === 'function' ? keyFn(row) : row[keyFn];
        const val = valFn(row);
        if (key && !isNaN(val)) {
          if (!groups[key]) groups[key] = [];
          groups[key].push(val);
        }
      }
      return groups;
    }

    function calculateResults(data, map) {
      const get = (row, key) => row[map[normalize(key)]] || "";

      const bySupplier = groupBy(data, r => r[map["supplier"]], r => daysBetween(get(r, "Order Date"), get(r, "Actual Delivery Date")));
      const byTransport = groupBy(data, r => r[map["transportationmode"]], r => daysBetween(get(r, "Order Date"), get(r, "Actual Delivery Date")));
      const byMonth = groupBy(data,
        r => {
          const d = parseDate(get(r, "Expected Delivery Date"));
          return isNaN(d) ? null : d.toLocaleString('default', { month: 'short' });
        },
        r => daysBetween(get(r, "Expected Delivery Date"), get(r, "Actual Delivery Date"))
      );
      const byDisruption = groupBy(data, r => r[map["disruptiontype"]], r => daysBetween(get(r, "Expected Delivery Date"), get(r, "Actual Delivery Date")));
      const byCategory = groupBy(data, r => r[map["productcategory"]], r => daysBetween(get(r, "Order Date"), get(r, "Actual Delivery Date")));

      const topSupplier = Object.entries(bySupplier).sort((a, b) => average(b[1]) - average(a[1]))[0] || ["N/A", []];
      const bestTransport = Object.entries(byTransport).sort((a, b) => average(a[1]) - average(b[1]))[0] || ["N/A", []];
      const worstMonth = Object.entries(byMonth).sort((a, b) => average(b[1]) - average(a[1]))[0] || ["N/A", []];
      const worstDisrupt = Object.entries(byDisruption).filter(e => e[0] && e[0] !== "None").sort((a, b) => average(b[1]) - average(a[1]))[0] || ["N/A", []];
      const bestCategory = Object.entries(byCategory).sort((a, b) => average(a[1]) - average(b[1]))[0] || ["N/A", []];

      currentOutput = `
Supplier with Highest Avg Lead Time: ${topSupplier[0]} â€” ${average(topSupplier[1]).toFixed(2)} days
Fastest Transport Mode: ${bestTransport[0]} â€” ${average(bestTransport[1]).toFixed(2)} days
Month with Highest Avg Delay: ${worstMonth[0]} â€” ${average(worstMonth[1]).toFixed(2)} days
Worst Disruption Type: ${worstDisrupt[0]} â€” ${average(worstDisrupt[1]).toFixed(2)} days
Best Product Category: ${bestCategory[0]} â€” ${average(bestCategory[1]).toFixed(2)} days`;

      document.getElementById("results").innerHTML = `
        <div class="result-card">
          <h2>ðŸ“Š Analysis Results</h2>
          <pre>${currentOutput}</pre>
        </div>`;
      renderChart(byMonth);
    }

    function renderChart(grouped) {
      const ctx = document.getElementById('delayChart').getContext('2d');
      const labels = Object.keys(grouped);
      const values = labels.map(l => average(grouped[l]).toFixed(2));
      new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{ label: 'Avg Delay by Month', data: values, backgroundColor: 'rgba(0,123,255,0.6)' }]
        },
        options: { responsive: true, plugins: { legend: { display: false } } }
      });
    }

    function downloadResult() {
      if (!currentOutput) return alert("No result to download yet.");
      const blob = new Blob([currentOutput], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "analysis_result.txt";
      a.click();
    }
  </script>
</body>
</html>
